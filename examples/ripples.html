<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name='viewport' content='width=device-width,initial-scale=1.0,user-scalable=no'>
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name='renderer' content='webkit'>
	<meta name='x5-page-mode' content='app'>
	<meta name='x5-orientation' content='portrait'>
	<meta name="x5-fullscreen" content="true">
	<meta name="full-screen" content="yes">
	<meta name='layoutmode' content='standard'>
	<meta name='mobile-web-app-capable' content='yes'>
	<meta name='browsermode' content='application'>
	<meta name='screen-orientation' content='portrait'>
	<meta name='format-detection' content='telephone=no'>
	<meta name='apple-mobile-web-app-capable' content='yes'>
	<meta name='apple-mobile-web-app-status-bar-style' content='black'>
	<title>Document</title>
	<script src="babylon.3.0.js"></script>
	<style>
		#renderCanvas{
			position: fixed;
			left: 0;bottom: 0;right: 0;top: 0;
			margin: auto;
			width: 100%;
			height: 100%;
		}
	</style>
	<script type="application/vertexShader" id="vertSrc_shader">
		attribute vec2 vertex;
        varying vec2 coord;
        void main() {
            coord = vertex * 0.5 + 0.5;
            gl_Position = vec4(vertex, 0.0, 1.0);
        }
	</script>
	<script type="application/fragmentShader" id="fragSrc_drop">
		precision highp float;
        const float PI = 3.141592653589793;

        uniform sampler2D texture;
        uniform vec2 center;
        uniform float radius;
        uniform float strength;

        varying vec2 coord;
        void main() {
            vec4 info = texture2D(texture, coord);
            float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);
            drop = 0.5 - cos(drop * PI) * 0.5;
            info.r += drop * strength;
            gl_FragColor = info ;
        }		
	</script>

    <script type="application/fragmentShader" id="fragSrc_update0">
        precision highp float;
        uniform sampler2D texture;
        uniform vec2 delta;
        varying vec2 coord;
        void main() {
            vec4 info = texture2D(texture, coord);
            vec2 dx = vec2(delta.x, 0.0);
            vec2 dy = vec2(0.0, delta.y);
            float average = (
            texture2D(texture, coord - dx).r +
            texture2D(texture, coord - dy).r +
            texture2D(texture, coord + dx).r +
            texture2D(texture, coord + dy).r
            ) * 0.25;
            info.g += (average - info.r) * 2.0;
            info.g *= 0.995;
            info.r += info.g;
            gl_FragColor = info;
        }
    </script>

    <script type="application/fragmentShader" id="fragSrc_update1">
        precision highp float;
        uniform sampler2D texture;
        uniform vec2 delta;
        varying vec2 coord;
        void main() {
            vec4 info = texture2D(texture, coord);
            vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);
            vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);
            info.ba = normalize(cross(dy, dx)).xz;
            gl_FragColor = info;
        }
    </script>

    <script type="application/vertexShader" id="vertSrc_render">
        precision highp float;
        uniform sampler2D samplerBackground;
        uniform sampler2D samplerRipples;
        uniform float perturbance;
        varying vec2 ripplesCoord;
        varying vec2 backgroundCoord;
        void main() {
            vec2 offset = -texture2D(samplerRipples, ripplesCoord).ba;
            float specular = pow(max(0.0, dot(offset, normalize(vec2(-0.6, 1.0)))), 4.0);
            gl_FragColor = texture2D(samplerBackground, backgroundCoord + offset * perturbance) + specular;
        }
    </script>
    <script type="application/fragmentShader" id="fragSrc_render">
        precision highp float;
        attribute vec2 vertex;
        uniform vec2 topLeft;
        uniform vec2 bottomRight;
        uniform vec2 containerRatio;
        varying vec2 ripplesCoord;
        varying vec2 backgroundCoord;
        void main() {
            backgroundCoord = mix(topLeft, bottomRight, vertex * 0.5 + 0.5);
            backgroundCoord.y = 1.0 - backgroundCoord.y;
            ripplesCoord = vec2(vertex.x, -vertex.y) * containerRatio * 0.5 + 0.5;
            gl_Position = vec4(vertex.x, -vertex.y, 0.0, 1.0);
        }
    </script>
</head>
<body>
<!-- https://www.eternalcoding.com/?p=113 -->
	<canvas id="renderCanvas"></canvas>
	<script>
		var canvas = document.getElementById('renderCanvas');
		var engine = new BABYLON.Engine(canvas, true);

		var scene = new BABYLON.Scene(engine);

		// var camera = new BABYLON.FreeCamera('', new BABYLON.Vector3(0, 5, 10), scene);

		var camera = new BABYLON.ArcRotateCamera("camera",0,1,25,BABYLON.Vector3.Zero(),scene);

		camera.setTarget(new BABYLON.Vector3.Zero());

		camera.attachControl(canvas, false);

		var light = new BABYLON.HemisphericLight('', new BABYLON.Vector3(0, 1, 0), scene);

        var DefaultRipplesOption = {
            resolution: 512,
            dropRadius: 20, //px
            perturbance: 0.04
        };

        var SIMUSIZEPX = 512;
    var SIMUWIDTH = 2;
    var GPGPU_NPASS = 2;
    var WATER_DEEP = 0.01;
    var RENDERING_FLOOR_SIZE = 0.5;
    var FLOWMIN = 2;
    var DFLOW = 2;


        var CANVAS = canvas;
    CANVAS.width = CANVAS.height = Math.max(window.innerWidth, window.innerHeight);
    var GL = engine._gl;
    var POINTER_X = 0.5, POINTER_Y = 0.5;
    var mouseMove = function (event) {
        SOURCEFLOW = FLOWMIN + Math.random() * DFLOW;
        var evPointer = event;
        if (('touches' in event) && event.touches.length !== 0) {
            evPointer = event.touches[0];
        }
        POINTER_X = (evPointer.clientX - CANVAS.offsetLeft) / CANVAS.width;
        POINTER_Y = 1 - evPointer.clientY / CANVAS.height;
    };
    var SOURCEFLOW = 0;


    CANVAS.addEventListener("mousemove", mouseMove, false);
    CANVAS.addEventListener("mouseout", function () {
        SOURCEFLOW = 0;
    }, false);
    CANVAS.addEventListener("mouseenter", function (e) {
        SOURCEFLOW = FLOWMIN + Math.random() * DFLOW;
        mouseMove(e);
    }, false);
    CANVAS.addEventListener("touchmove", mouseMove, false);
    CANVAS.addEventListener("touchstart", function (e) {
        if (e.touches.length === 1) {
            SOURCEFLOW = FLOWMIN + Math.random() * DFLOW;
            mouseMove(e);
        }
    }, false);
    CANVAS.addEventListener("touchend", function (e) {
        if (e.touches.length === 0) {
            SOURCEFLOW = 0;
        }
    }, false);
    var SCALESCREEN = [CANVAS.width / window.innerWidth, CANVAS.height / window.innerHeight];
    
    var EXT_FLOAT = GL.getExtension('OES_texture_float') || GL.getExtension('MOZ_OES_texture_float') || GL.getExtension('WEBKIT_OES_texture_float');
    var vertSrc_shader = document.getElementById("vertSrc_shader").innerHTML;
    var fragSrc_drop = document.getElementById("fragSrc_drop").innerHTML;
    var fragSrc_update0 = document.getElementById("fragSrc_update0").innerHTML;
    var fragSrc_update1 = document.getElementById("fragSrc_update1").innerHTML;
    var vertSrc_render = document.getElementById("vertSrc_render").innerHTML;
    var fragSrc_render = document.getElementById("fragSrc_render").innerHTML;



    

    

    var get_shader = function (source, type, typeString) {
        var shader = GL.createShader(type);
        GL.shaderSource(shader, source);
        GL.compileShader(shader);
        if (!GL.getShaderParameter(shader, GL.COMPILE_STATUS)) {
            alert("ERROR IN " + typeString + " SHADER : " + GL.getShaderInfoLog(shader));
            return false;
        }
        return shader;
    };
    var get_shaderProgram = function (vertex_source, fragment_source, typeStr) {
        var shader_vertex = get_shader(vertex_source, GL.VERTEX_SHADER, typeStr + " VERTEX");
        var shader_fragment = get_shader(fragment_source, GL.FRAGMENT_SHADER, typeStr + " FRAGMENT");
        var shader_program = GL.createProgram();
        GL.attachShader(shader_program, shader_vertex);
        GL.attachShader(shader_program, shader_fragment);
        GL.linkProgram(shader_program);
        return shader_program;
    };
    var SHP_VARS = {};
    var SHP_RENDERING = get_shaderProgram(vertSrc_render, fragSrc_render, "RENDER");
    SHP_VARS.rendering = {
        H: GL.getUniformLocation(SHP_RENDERING, "H"),
        L: GL.getUniformLocation(SHP_RENDERING, "L"),
        l: GL.getUniformLocation(SHP_RENDERING, "l"),
        scaleScreen: GL.getUniformLocation(SHP_RENDERING, "scaleScreen"),
        sampler: GL.getUniformLocation(SHP_RENDERING, "sampler"),
        sampler_normals: GL.getUniformLocation(SHP_RENDERING, "sampler_normals"),
        sampler_mask: GL.getUniformLocation(SHP_RENDERING, "sampler_mask"),
        position: GL.getAttribLocation(SHP_RENDERING, "position")
    };
    var SHP_WATER = get_shaderProgram(vertSrc_render, fragSrc_water, "WATER");
    SHP_VARS.water = {
        dt: GL.getUniformLocation(SHP_WATER, "dt"),
        H: GL.getUniformLocation(SHP_WATER, "H"),
        b: GL.getUniformLocation(SHP_WATER, "b"),
        g: GL.getUniformLocation(SHP_WATER, "g"),
        mouse: GL.getUniformLocation(SHP_WATER, "mouse"),
        sourceFlow: GL.getUniformLocation(SHP_WATER, "sourceFlow"),
        sourceRadius: GL.getUniformLocation(SHP_WATER, "sourceRadius"),
        scaleScreen: GL.getUniformLocation(SHP_WATER, "scaleScreen"),
        epsilon: GL.getUniformLocation(SHP_WATER, "epsilon"),
        scale: GL.getUniformLocation(SHP_WATER, "scale"),
        sampler_water: GL.getUniformLocation(SHP_WATER, "sampler_water"),
        sampler_normals: GL.getUniformLocation(SHP_WATER, "sampler_normals"),
        sampler_mask: GL.getUniformLocation(SHP_WATER, "sampler_mask"),
        position: GL.getAttribLocation(SHP_WATER, "position")
    };
    var SHP_COPY = get_shaderProgram(vertSrc_render, fragSrc_copy, "COPY");
    SHP_VARS.copy = {
        scale: GL.getUniformLocation(SHP_COPY, "scale"),
        sampler: GL.getUniformLocation(SHP_COPY, "sampler"),
        position: GL.getAttribLocation(SHP_COPY, "position")
    };
    var SHP_NORMALS = get_shaderProgram(vertSrc_render, fragSrc_normals, "NORMALS");
    SHP_VARS.normals = {
        sampler: GL.getUniformLocation(SHP_NORMALS, "sampler"),
        scale: GL.getUniformLocation(SHP_NORMALS, "scale"),
        epsilon: GL.getUniformLocation(SHP_NORMALS, "epsilon"),
        position: GL.getAttribLocation(SHP_NORMALS, "position")
    };

    var quad_vertex = [-1, -1, 1, -1, 1, 1, -1, 1];
    var QUAD_VERTEX = GL.createBuffer();
    GL.bindBuffer(GL.ARRAY_BUFFER, QUAD_VERTEX);
    GL.bufferData(GL.ARRAY_BUFFER, new Float32Array(quad_vertex), GL.STATIC_DRAW);
    
    var quad_faces = [0, 1, 2, 0, 2, 3];
    var QUAD_FACES = GL.createBuffer();
    GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, QUAD_FACES);
    GL.bufferData(GL.ELEMENT_ARRAY_BUFFER, new Uint16Array(quad_faces), GL.STATIC_DRAW);

    var nLoaded = 0;
    var check_loaded = function () {
        ++nLoaded;
        if (nLoaded === 2) {
            GL.activeTexture(GL.TEXTURE2);
            GL.bindTexture(GL.TEXTURE_2D, texture_mask);
            GL.activeTexture(GL.TEXTURE0);
            console.log('Loading finished, launch animate()');
            animate(new Date().getTime());
        }
    };
    var createTexture = function (url) {
        var renderingImage = new Image();
        renderingImage.src = url;
        var texture = GL.createTexture();
        renderingImage.onload = function () {
            GL.bindTexture(GL.TEXTURE_2D, texture);
            GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.LINEAR);
            GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR);
            GL.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA, GL.RGBA, GL.UNSIGNED_BYTE, renderingImage);
            check_loaded();
        };
        return texture;
    };
    var fb_water = GL.createFramebuffer();
    GL.bindFramebuffer(GL.FRAMEBUFFER, fb_water);

    var texture_water = GL.createTexture();
    GL.bindTexture(GL.TEXTURE_2D, texture_water);

    GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.NEAREST);
    GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST);
    GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE);
    GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE);
    GL.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA, SIMUSIZEPX, SIMUSIZEPX, 0, GL.RGBA, GL.FLOAT, null);

    var texture_water_copy = GL.createTexture();
    GL.bindTexture(GL.TEXTURE_2D, texture_water_copy);
    GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.NEAREST);
    GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST);
    GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE);
    GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE);
    GL.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA, SIMUSIZEPX, SIMUSIZEPX, 0, GL.RGBA, GL.FLOAT, null);

    var texture_normals = GL.createTexture();
    GL.bindTexture(GL.TEXTURE_2D, texture_normals);
    GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.NEAREST);
    GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST);
    GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE);
    GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE);
    GL.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA, SIMUSIZEPX, SIMUSIZEPX, 0, GL.RGBA, GL.FLOAT, null);

    GL.disable(GL.DEPTH_TEST);
    GL.disable(GL.SCISSOR_TEST);
    GL.clearColor(0.0, 0.0, 0.0, 0.0);

    GL.useProgram(SHP_RENDERING);
    GL.uniform1f(SHP_VARS.rendering.H, WATER_DEEP);
    GL.uniform1f(SHP_VARS.rendering.L, SIMUWIDTH);
    GL.uniform1f(SHP_VARS.rendering.l, RENDERING_FLOOR_SIZE);
    GL.uniform1i(SHP_VARS.rendering.sampler, 0);
    GL.uniform1i(SHP_VARS.rendering.sampler_normals, 1);
    GL.uniform1i(SHP_VARS.rendering.sampler_mask, 2);
    GL.uniform2fv(SHP_VARS.rendering.scaleScreen, SCALESCREEN);
    
    GL.vertexAttribPointer(SHP_VARS.rendering.position, 2, GL.FLOAT, false, 8, 0);
    GL.bindBuffer(GL.ARRAY_BUFFER, QUAD_VERTEX);
    GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, QUAD_FACES);
    GL.disableVertexAttribArray(SHP_VARS.rendering.position);

    GL.useProgram(SHP_WATER);
    GL.uniform1i(SHP_VARS.water.sampler_water, 0);
    GL.uniform1i(SHP_VARS.water.sampler_normals, 1);
    GL.uniform1i(SHP_VARS.water.sampler_mask, 2);
    GL.uniform2fv(SHP_VARS.water.scaleScreen, SCALESCREEN);
    GL.uniform1f(SHP_VARS.water.g, -9.8);
    GL.uniform1f(SHP_VARS.water.H, WATER_DEEP);
    GL.uniform1f(SHP_VARS.water.b, 0.001);
    GL.uniform1f(SHP_VARS.water.epsilon, 1 / SIMUSIZEPX);
    GL.uniform1f(SHP_VARS.water.scale, SIMUWIDTH / SIMUSIZEPX);
    GL.uniform1f(SHP_VARS.water.sourceRadius, 0.005);

    GL.enableVertexAttribArray(SHP_VARS.water.position);
    GL.vertexAttribPointer(SHP_VARS.water.position, 2, GL.FLOAT, false, 8, 0);
    GL.bindBuffer(GL.ARRAY_BUFFER, QUAD_VERTEX);
    GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, QUAD_FACES);
    GL.disableVertexAttribArray(SHP_VARS.water.position);

    GL.useProgram(SHP_COPY);
    GL.uniform1f(SHP_VARS.copy.scale, SIMUSIZEPX);
    GL.uniform1i(SHP_VARS.copy.sampler, 0);

    GL.enableVertexAttribArray(SHP_VARS.copy.position);
    GL.vertexAttribPointer(SHP_VARS.copy.position, 2, GL.FLOAT, false, 8, 0);
    GL.bindBuffer(GL.ARRAY_BUFFER, QUAD_VERTEX);
    GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, QUAD_FACES);
    GL.disableVertexAttribArray(SHP_VARS.copy.position);

    GL.useProgram(SHP_NORMALS);
    GL.uniform1i(SHP_VARS.normals.sampler, 0);
    GL.uniform1f(SHP_VARS.normals.epsilon, 1 / SIMUSIZEPX);
    GL.uniform1f(SHP_VARS.normals.scale, SIMUWIDTH);

    GL.enableVertexAttribArray(SHP_VARS.normals.position);
    GL.vertexAttribPointer(SHP_VARS.normals.position, 2, GL.FLOAT, false, 8, 0);
    GL.bindBuffer(GL.ARRAY_BUFFER, QUAD_VERTEX);
    GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, QUAD_FACES);
    GL.disableVertexAttribArray(SHP_VARS.normals.position);

    var old_timestamp = new Date().getTime();
    var old_timestamp = 0;

    var renderingTexture = createTexture('images/water.jpg');
    var texture_mask = createTexture('images/mask.png');

    window.requestAnimFrame = (function(){
	  return  window.requestAnimationFrame       ||
	          window.webkitRequestAnimationFrame ||
	          window.mozRequestAnimationFrame    ||
	          function( callback ){
	            window.setTimeout(callback, 1000 / 60);
	          };
	})();

    var animate = function (timestamp) {

        var dt = (timestamp - old_timestamp) / 1000; //time step in seconds;

        dt = Math.min(Math.abs(dt), 0.017);
        old_timestamp = timestamp;
        GL.bindFramebuffer(GL.FRAMEBUFFER, fb_water);

        for (var i = 0; i < GPGPU_NPASS; i++) {
            GL.useProgram(SHP_COPY);
            GL.viewport(0.0, 0.0, SIMUSIZEPX, SIMUSIZEPX);

            GL.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT0, GL.TEXTURE_2D, texture_water_copy, 0);
            GL.enableVertexAttribArray(SHP_VARS.copy.position);
            GL.bindTexture(GL.TEXTURE_2D, texture_water);
            GL.drawElements(GL.TRIANGLES, 6, GL.UNSIGNED_SHORT, 0);
            GL.disableVertexAttribArray(SHP_VARS.copy.position);

            GL.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT0, GL.TEXTURE_2D, texture_water, 0);
            GL.useProgram(SHP_WATER);
            GL.enableVertexAttribArray(SHP_VARS.water.position);
            GL.activeTexture(GL.TEXTURE1);
            GL.bindTexture(GL.TEXTURE_2D, texture_normals);

            GL.activeTexture(GL.TEXTURE0);
            GL.bindTexture(GL.TEXTURE_2D, texture_water_copy);

	         if (i === 0) {
	                GL.uniform2f(SHP_VARS.water.mouse, POINTER_X, POINTER_Y);
	                GL.uniform1f(SHP_VARS.water.sourceFlow, SOURCEFLOW);
	                GL.uniform1f(SHP_VARS.water.dt, dt / GPGPU_NPASS);
	        

	            GL.drawElements(GL.TRIANGLES, 6, GL.UNSIGNED_SHORT, 0);
	            GL.disableVertexAttribArray(SHP_VARS.water.position);
	            GL.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT0, GL.TEXTURE_2D, texture_normals, 0);
	            GL.useProgram(SHP_NORMALS);
	            GL.enableVertexAttribArray(SHP_VARS.normals.position);
	            GL.bindTexture(GL.TEXTURE_2D, texture_water);
	            GL.drawElements(GL.TRIANGLES, 6, GL.UNSIGNED_SHORT, 0);
	            GL.disableVertexAttribArray(SHP_VARS.normals.position);
	        }

	        GL.bindFramebuffer(GL.FRAMEBUFFER, null);
	        GL.useProgram(SHP_RENDERING);
	        GL.enableVertexAttribArray(SHP_VARS.rendering.position);
	        GL.viewport(0.0, 0.0, CANVAS.width, CANVAS.height);
	        GL.activeTexture(GL.TEXTURE1);
	        GL.bindTexture(GL.TEXTURE_2D, texture_normals);
	        GL.activeTexture(GL.TEXTURE0);
	        GL.bindTexture(GL.TEXTURE_2D, renderingTexture);
	        GL.drawElements(GL.TRIANGLES, 6, GL.UNSIGNED_SHORT, 0);
	        GL.disableVertexAttribArray(SHP_VARS.rendering.position);
	        GL.flush();

	        // 
	        
	    };
        console.log(1);
// 
 		window.requestAnimationFrame(animate);
    };


    // scene.registerBeforeRender() = animate;

    

   

        
// var scene = new BABYLON.Scene(engine);
//     var camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 4, Math.PI / 2.5, 200, BABYLON.Vector3.Zero(), scene);
//     camera.attachControl(canvas, true);
//     camera.minZ = 0.1;

	</script>
</body>
</html>